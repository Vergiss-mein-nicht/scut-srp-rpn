# 规则库
## 更新记录
* 2022.12.29 
* 2023.1.20  
  `CONDITION`增加新成员`rearPart`和两个构造函数。<br>`ComparisionType`增加两种时间规则下的比较类型：`CERTAIN_TOKEN_DURATION`和`TIME_TO_REACH_CERTAIN_TOKEN`。<br>`TOKEN_COMPARE`的归属从事件类型改为状态类型。<br>对每个比较类型增加更具体的注释。<br>新增`StateRule`状态规则。<br>`RuleManager`的`addRule`方法重命名为`appendRule`，增加`swapRule`和`moveRule`方法。
---
## 组成
`rule`文件夹、`operation`文件夹和`RuleMananger`类，每个网配备一个`RuleManager`，通过此类操纵规则库。
***
## `RuleManager`使用方法
### 仿真时的使用
```C++
    /**
     * @brief 仿真前提供初始化信息
     * @param componentList 提供网络信息，从tabWidget中获取此指针
     * @param initInfo 初始化信息
     */
    void initRule(ComponentList*componentList,RULE_INITIALIZE_INFOMATION initInfo);
    /**
     * @brief （仿真阶段使用）判断规则是否满足，并进行规则对应的操作，需先使用initRule提供仿真相关信息
     * @return 若发生重构，则返回true，否则返回false
     */
    bool applyRule();
```
#### `RULE_INITIALIZE_INFOMATION`的成员说明
```C++
typedef struct
{
    double step;//仿真步长
}RULE_INITIALIZE_INFOMATION;
```
---
### 仿真前的规则管理
```C++
    void appendRule(BaseRule*);
    const QList<BaseRule*>* getRuleList();
    /**
     * @param index 规则的索引
     * @return 成功返回true，其他情况如未找到规则返回false
     */
    bool deleteRule(int index);
    /**
     * @brief 交换两个索引位置的规则，提供索引有效性验证
     * @param 两条规则的索引
     * @return 成功返回true，否则返回false
     */
    bool swapRule(int a,int b);
    /**
     * @brief 将规则移至对应索引处，空出来的位置由后面的规则依次前移补上，提供索引有效性验证
     * @param from 要引动规则的索引
     * @param to 移动目标位置的索引
     * @return 成功返回true，否则返回false
     */
    bool moveRule(int from,int to);
```
#### 各类规则说明
`BaseRule`:规则基类，抽象类，构造函数接受的参数为大部分子类规则通用的，如下
* `TimeRule`：时间规则、`EventRule`：事件规则、`StateRule`：状态规则 构造函数接受的参数与基类一致
```C++
    /**
     * @param name 规则名称
     * @param comment 规则备注
     * @param conditionList 规则判断条件的运算式，内层QList为与运算，外层QList为或运算
     * @param operationList 规则满足时要执行的操作
     */
BaseRule(QString name,QString comment,QList<QList<CONDITION> > conditionList,QList<BaseOperation*>operationList);
```
##### `CONDITION`的成员说明
```C++
typedef struct _CONDITION
{
    ComparisionType conditionOption;//比较的类型，如库所token的比较，仿真总时间的比较
    QString monitorFactor;//监控的因素
    ComparisonSymbol symbol;//比较的符号
    QVariant value;//被比较的数值
    _CONDITION* rearPart;//蕴含式的后半部，即离散数学中的“→”，拥有此指针的结构体为前半部，用于“位置的token值在一个数值范围的维持时间”这种前一个条件满足后才监测后一个因素的规则类型

    _CONDITION(ComparisionType option,QString factor,ComparisonSymbol symbol,QVariant value)
        :conditionOption(option),monitorFactor(factor),symbol(symbol),value(value),rearPart(nullptr)
    {}
    _CONDITION(ComparisionType option,QString factor,ComparisonSymbol symbol,QVariant value,_CONDITION* rp)
        :conditionOption(option),monitorFactor(factor),symbol(symbol),value(value),rearPart(rp)
    {}
} CONDITION,* pCONDITION;
```
###### `CONDITION`使用到的两个枚举类型
```C++
//比较的符号
enum ComparisonSymbol{EQUAL=1,NOT_EQUAL,GREATER,LESS,GREATER_EQUAL,LESS_EQUAL};

//比较的类型，每种规则只处理对应的类型，如时间规则只处理时间规则相关类型
enum ComparisionType{
    /*时间规则相关类型*/
    TIME_POINT_COMPARE=1,//当前总仿真时间和某个时间点比较。比较类型为此项时，监控因素将忽略，可填空字符串。比较形式如下：<当前时间点><比较符号><被比较的数值>
    FIRE_REACH_TIME_DURATION=2,//持续触发达到某个时长   **！次要需求，暂无实现！**
    CERTAIN_TOKEN_DURATION,//对token的比较满足，并维持一定的时间。前部CONDITION为token比较，后部为时间比较（监控因素将忽略），即：token比较→时间比较
    TIME_TO_REACH_CERTAIN_TOKEN,//令token满足比较,所需的时间。token比较→时间比较（后部的监控因素将忽略）

    /*事件规则相关类型*/

    /*状态规则相关类型*/
    TOKEN_COMPARE//比较token是否符合范围
};
```
例：`CONDITION{TOKEN_COMPARE,"cname&1&pname",EQUAL,1.5}`代表监视id为`cname&1&pname`的库所，当其token**等于**`1.5`时,此`CONDITION`代表的条件满足。
##### 规则用到的操作说明
`BaseOperation`：操作基类,抽象类。

`AddOperation`：传入组件的名称，创建一个新的组件实例，编号自动分配。要传入已有实例id以进行增加组件操作，使用RecoverOperation。
```C++
AddOperation(QString componentName);
```
`DeleteOperation`:通过组件id删除对应实例。
```C++
DeleteOperation(QString componentId);
```
`MergeOperation`:合并两个端口
```C++
MergeOperation(QString portId_1,QString portId_2);
```
`RecoverOperation`:传入实例id,往网中恢复实例，不合并任何端口。相当于传入已有组件实例id的add操作。
```C++
RecoverOperation(QString componentId)
```
`ReplaceWithExistInstanceOperation`:使用被删除的实例来替换要删除的旧组件实例，并可选择合并一系列端口。若要新建自动分配编号的组件来替换，使用ReplaceWithNewOperation。
```C++
    /* @param componentIdToReplace 要删除的组件id
     * @param componentIdToAdd 要加入的已有实例id
     * @param mergePortList 一系列要合并的端口
     */
    ReplaceWithExistInstanceOperation(QString componentIdToReplace,QString componentIdToAdd,QList<QPair<QString,QString> >mergePortList);
```
`ReplaceWithNewOperation`:使用自动分配编号的新实例来替换要删除的旧组件实例，并可选择合并一系列端口
```C++
    /**
     * @param componentIdToReplace 要删除的组件实例id
     * @param componentNameToAdd 要新增的组件名称
     * @param mergePortList 一系列要合并的端口，使用NEW_COMPONENT_ID来指代新增组件的id，例：NEW_COMPONENT_ID+"&"+placeName
     */
    ReplaceWithNewOperation(QString componentIdToReplace,QString componentNameToAdd,QList<QPair<QString,QString> >mergePortList);
```
`SeperateOperation`:拆开合并的端口
```C++
SeperateOperation(QString compoundPortId);
```